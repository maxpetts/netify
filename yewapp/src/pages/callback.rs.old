use base64::encode;
use gloo_console::log;
use gloo_utils::{body, document, window};
use wasm_bindgen::JsCast;
use wasm_bindgen::JsValue;
use wasm_bindgen_futures::{spawn_local, JsFuture};
use web_sys::{console::log, Request, Response, Url};
use web_sys::{RequestInit, UrlSearchParams};
use yew::prelude::*;
use yew_router::prelude::*;

use yewdux::prelude::*;

use crate::State;

#[function_component(Callback)]
pub fn callback() -> Html {
    let error = use_state(|| "URL Referral error");
    let referrer: &str = &document().referrer();
    let (state, dispatch) = use_store::<State>();

    log! {"REF: {}", referrer};

    log! {"In profile cont"};
    // let (code, state): (String, String);
    let (code, hash): (Option<String>, Option<String>);

    let url = Url::new(&document().url().unwrap()).unwrap(); // do some better handling please
    log!(url.clone());
    let search_params = web_sys::UrlSearchParams::new_with_str(&url.search());
    if let Ok(UrlSearchParams) = &search_params {
        (code, hash) = (
            search_params.as_ref().unwrap().get("code"),
            search_params.as_ref().unwrap().get("state"),
        );

        match (code, hash) {
            (Some(code), Some(hash)) => {
                dispatch.reduce_mut(|state| state.auth_token = code.to_string());

                if state.hash != hash {
                    error.set("Hash mismatch");
                };
            }
            (None, Some(_)) => {
                let err = search_params.as_ref().unwrap().get("error");
                match err {
                    Some(e) => match e.as_str() {
                        "access_denied" => error.set(
                            "You denied access. You've seen too much. I cannot let you continue.",
                        ),
                        _ => error.set("un-handled error encountered"),
                    },
                    None => error.set("Spotify hasn't provided an error type.."),
                }
            }
            (Some(_), None) => error.set("No hash returned by Spotify"),
            (None, None) => error.set("Nothing returned. PANIC PANIC"),
        }
    };
    log! {"In callback cont"};

    // let client_id = store
    //     .state()
    //     .map(|state| state.client_id.clone())
    //     .unwrap_or_default();
    // let client_secret = store
    //     .state()
    //     .map(|state| state.client_secret.clone())
    //     .unwrap_or_default();

    // let auth_token = store
    //     .state()
    //     .map(|state| state.auth_token.clone())
    //     .unwrap_or_default();

    // let res = Request::body(
    //     Request::post("https://accounts.spotify.com/api/token").headers(headers),
    //     format! {"grant_type: \"authorization_code\", code: {}, redirect_uri: localhost:8080/callback", state.auth_token},
    // ).send();

    let mut opts = RequestInit::new();
    opts.method("POST");
    // let body = &JsValue::from_str(
    //     &format! {"grant_type: authorization_code, code: {}, redirect_uri: localhost:8080/callback", state.auth_token},
    // );
    let body = serde_json::json!({
        "grant_type" : "authorization_code",
        "code" : format!("{}", state.auth_token),
        "redirect_uri" : "localhost:8080/callback"
    });

    opts.body(Some(&JsValue::from_serde(&body).unwrap()));
    log! {"{}", &opts};
    let request =
        Request::new_with_str_and_init("https://accounts.spotify.com/api/token", &opts).unwrap();
    request
        .headers()
        .set("Content-Type", "application/x-www-form-urlencoded")
        .expect("Couldn't set content-type header");
    request
        .headers()
        .set(
            "Authorization",
            &encode(format! {"{}:{}", state.client_id, state.client_secret}.as_bytes()),
        )
        .expect("Couldn't set Authorization header");

    // let res = web_sys::window().fetch_with_request(&request);

    spawn_local(async move {
        let window = web_sys::window().unwrap();
        let resp_value = JsFuture::from(window.fetch_with_request(&request))
            .await
            .expect("error with request");

        let resp: Response = resp_value.dyn_into().unwrap();
        let json = JsFuture::from(resp.json().unwrap()).await.unwrap();

        log! {"resp: {}", json};
    });
    // log! {res.body()}

    // res.unwrap()

    html! {
        {*error}
    }
}
